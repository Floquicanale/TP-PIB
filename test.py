# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'test.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtWidgets import QFileDialog, QLabel, QMainWindow, QMessageBox
import SimpleITK as sitk
import sys
import numpy as np
import matplotlib.pyplot as plt
import mahotas


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(748, 600)

        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.Imagen = QtWidgets.QPushButton(self.centralwidget)
        self.Imagen.setGeometry(QtCore.QRect(100, 500, 200, 40))
        self.Imagen.setObjectName("Imagen")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(490, 100, 500, 500))
        self.label.setScaledContents(True)
        self.label.setObjectName("IMG1")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(1010, 100, 500, 500))
        self.label_2.setScaledContents(True)
        self.label_2.setObjectName("IMG2")
        self.min = QtWidgets.QLabel(self.centralwidget)
        self.min.setGeometry(QtCore.QRect(50, 445, 200, 40))
        self.min.setScaledContents(True)
        self.min.setObjectName("IMG2")
        self.min_edit = QtWidgets.QLineEdit(self.centralwidget)
        self.min_edit.setGeometry(QtCore.QRect(200, 450, 90, 30))
        self.min_edit.setObjectName("UserInput")
        self.min_edit.setText(str(1))
        self.seed = QtWidgets.QLineEdit(self.centralwidget)
        self.seed.setGeometry(QtCore.QRect(600, 950, 200, 31))
        self.seed.setObjectName("UserInput2")
        self.seed.setText(str((1,1)))
        self.seed.hide()
        int_validator = QtGui.QIntValidator()
        self.min_edit.setValidator(int_validator)
        self.Segmentar = QtWidgets.QPushButton(self.centralwidget)
        self.Segmentar.setGeometry(QtCore.QRect(500, 700, 150, 31))
        self.Segmentar.setObjectName("Segmentar")
        self.Luz = QtWidgets.QPushButton(self.centralwidget)
        self.Luz.setGeometry(QtCore.QRect(700, 700, 150, 31))
        self.Luz.setObjectName("Luz")
        self.Luz.hide()
        self.Placa = QtWidgets.QPushButton(self.centralwidget)
        self.Placa.setGeometry(QtCore.QRect(700, 750, 150, 31))
        self.Placa.setObjectName("Placa")
        self.Placa.hide()
        self.Mejorar = QtWidgets.QPushButton(self.centralwidget)
        self.Mejorar.setGeometry(QtCore.QRect(600, 900, 200, 31))
        self.Mejorar.setObjectName("Mejorar")
        self.Mejorar.hide()
        self.Calcular = QtWidgets.QPushButton(self.centralwidget)
        self.Calcular.setGeometry(QtCore.QRect(1250, 620, 150, 32))
        self.Calcular.setObjectName("Calcular")
        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(1200, 670, 100, 30))
        self.textEdit.setObjectName("Area 1")
        self.textEdit_3 = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit_3.setGeometry(QtCore.QRect(1200, 710, 100, 30))
        self.textEdit_3.setObjectName("Area 2")
        self.textEdit_4 = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit_4.setGeometry(QtCore.QRect(1200, 750, 100, 30))
        self.textEdit_4.setObjectName("Coef")
        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(1350, 670, 113, 30))
        self.lineEdit.setObjectName("Area1")
        self.lineEdit_2 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2.setGeometry(QtCore.QRect(1350, 710, 113, 30))
        self.lineEdit_2.setObjectName("Area2")
        self.lineEdit_3 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_3.setGeometry(QtCore.QRect(1350, 750, 113, 30))
        self.lineEdit_3.setObjectName("Area3")
        self.scroll_bar = QtWidgets.QScrollBar(self.centralwidget)
        self.scroll_bar.setGeometry(QtCore.QRect(450, 100, 20, 500))
        self.scroll_bar.setOrientation(Qt.Vertical)
        self.scroll_bar.hide()

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 748, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        #Seteo las imagenes a negro
        black_image = np.zeros((1000, 1000), dtype=np.uint8)  # Asume dimensiones de 401x361, ajusta según tus necesidades
        pm = self.makePixmap(black_image)
        self.label.setPixmap(pm)
        self.label_2.setPixmap(pm)


        #Aca empieza la magia
        self.Imagen.clicked.connect(self.elegir)
        self.Segmentar.clicked.connect(self.show_op)
        self.Calcular.clicked.connect(self.parametros)
        self.scroll_bar.valueChanged.connect(self.actualizar_imagen)
        self.Mejorar.clicked.connect(self.mejorar_segmentacion)

        self.imagen_dicom = np.array([], dtype=np.float64)
        self.imagenes = np.array([], dtype=np.float64)
        self.imgs = np.array([], dtype=np.float64)
        self.img = np.array([], dtype=np.float64)
        self.img_luz = np.array([], dtype=np.float64)
        self.img_placa = np.array([], dtype=np.float64)
        self.flag_luz = 0
        self.flag_placa = 0

    def mostrar_mensaje_error(self, mensaje):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Critical)
        msg.setText("Error")
        msg.setInformativeText(mensaje)
        msg.setWindowTitle("Error")
        msg.exec_()

        
    def makePixmap(self, image):
        height, width = image.shape
        bytes_per_line = 1 * width
        q_image = QImage(image.data, width, height, bytes_per_line, QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(q_image)

        return pixmap
        
    def elegir(self):
        main_window = QMainWindow()
        ruta_imagen, _ = QFileDialog.getOpenFileName(main_window, "Open Image", "C:/Users/floqu/Documents/2023/CUAT 2/Procesamiento de imagenes", "Dicom Files (*.dcm)")

        if ruta_imagen:
                self.imagen_dicom = sitk.ReadImage(ruta_imagen)
                self.imagenes = sitk.GetArrayFromImage(self.imagen_dicom)
                #self.img = self.imagenes[378]
                self.scroll_bar.show()
                minimo = int(self.min_edit.text()) - 1
                print(minimo)
                for i in range(minimo, minimo+51):
                    pm = self.makePixmap(self.imagenes[i])
                    self.imgs = np.append(self.imgs, pm)
                #self.imagenes = self.imagenes[min:min+52, :, :]
                #print(self.imagenes)
                #print(len(self.imgs))
                self.scroll_bar.setMaximum(len(self.imgs) - 1)
                self.img = self.imagenes[minimo]
                self.label.setPixmap(self.imgs[0])
        else:
                print("No se pudo cargar la imagen.")


        return 
    
    def actualizar_imagen(self, value):
        valor_actual = value

        if valor_actual < len(self.imgs):
            self.label.setPixmap(self.imgs[valor_actual])
            self.img = self.imagenes[int(self.min_edit.text()) - 1+valor_actual]
            print(int(self.min_edit.text()) - 1+valor_actual)

        
        
    def show_op(self):
        #aca va el algoritmo de segmentación
        self.Luz.show()
        self.Mejorar.show()
        self.seed.show()

        self.Luz.clicked.connect(self.get_light)
        self.Placa.clicked.connect(self.get_placa)
        
        return
    
    def crear_circulos(self, img, paso = 10):
        alto, ancho = img.shape

        centro_x =ancho//2
        centro_y = alto//2
        #Encuentro el radio máximo que puede tener la imagen
        radio = 0
        d_circunf = {}

        while centro_x - radio >= 0 and centro_y - radio >= 0:
            x_coords = []
            y_coords = []
            # Recorro la circunferencia
            for angulo in range(0, 360):
                x = int(np.cos(angulo) * radio + centro_x)
                y = int(np.sin(angulo) * radio + centro_y)

                if 0 <= x < ancho and 0 <= y < alto:
                    # Agrega el píxel a la lista
                    x_coords.append(x)
                    y_coords.append(y)

            d_circunf[f'{radio}'] = [x_coords, y_coords]
            radio += paso

        return d_circunf
    
    def blanco_afuera_del_circulo(self, img, radio):
        img_aux = img.copy()
        centro = (img.shape[1]//2, img.shape[0]//2)
        y, x = np.ogrid[:img.shape[0], :img.shape[1]]
        dist_from_center = np.sqrt((x - centro[0])**2 + (y - centro[1])**2)
        img_aux[dist_from_center > radio] = 255
        return img_aux
    
    def calcular_region(self, img, seccion ="luz", paso_circulos = 10):
        analizados = np.empty((0, 2), dtype=float)

        #if seccion == "lumen":
        #    sec = 4
        #    umbral = 10
        if seccion == "luz":
            sec = 40

        elif seccion == "placa":
            sec = 60

        #calculo los circulos
        circulos = self.crear_circulos(img, paso = paso_circulos)

        for clave in circulos.keys():
            
            img_new = self.blanco_afuera_del_circulo(img, int(clave))
            entropia = mahotas.features.haralick(img_new).mean()
            analizados = np.append(analizados, np.array([[entropia, int(clave)]]), axis=0)



        for v in range(analizados.shape[0]):
            umbral = 0
            if (v+1 < analizados.shape[0] and v-4 >= 0):
            #diferencia = abs(float(analizados[v][0]) - float(analizados[v+1][0]))
            #Hace el promedio en vez de la diferencia
                for j in range(v-4, v+1):
                    umbral += float(analizados[j][0])
                umbral = umbral/(v+1)
            else: umbral = 1000
            print("umbral",umbral)
            if (float(analizados[v+1][0]) > 10*umbral and v>sec):
                print("valor actual:",analizados[v+1][0])
                break
            #me quedo con v
        print("circulo de radio:",analizados[v][1])
        img_def = self.blanco_afuera_del_circulo(img, analizados[v][1])
        return img_def
    
    '''
    def calcular_region(self, img, seccion ="placa", paso_circulos = 10, radio_vecis = 1, flaggg = 0):
        fil, col = img.shape
        img_new = img.copy()
        analizados = np.empty((0, 2), dtype=float)

        #if seccion == "lumen":
        #    sec = 4
        #    umbral = 10
        if seccion == "luz":
            sec = 40

        elif seccion == "placa":
            sec = 60

        #calculo los circulos
        circulos = self.crear_circulos(img, paso = paso_circulos)

        for clave in circulos.keys():
            n_gris = 0
            x_coord = circulos[clave][0]
            y_coord = circulos[clave][1]

            for n in range(len(x_coord)):
            #recorro los vecinos
                for i in range(-radio_vecis, radio_vecis + 1):
                    for j in range(-radio_vecis, radio_vecis + 1):
                        if(x_coord[n] + i < fil and y_coord[n] + j < col):
                            n_gris += img[x_coord[n] + i, y_coord[n] + j]

            analizados = np.append(analizados, np.array([[n_gris/n, clave]]), axis=0)
        print(analizados)

        for v in range(analizados.shape[0]):
            umbral = 0
            if v+1 < analizados.shape[0]:
                #diferencia = abs(float(analizados[v][0]) - float(analizados[v+1][0]))
                for z in range(v+1):
                    umbral += float(analizados[z][0])
                umbral = umbral/(v+1)
                if (float(analizados[v+1][0]) > umbral and v>sec):
                    break
                    #me quedo con v
        if (flaggg == 0):
            print("circulo de radio:",analizados[v][1])

            img_new = self.blanco_afuera_del_circulo(img_new, int(analizados[v][1]))
        elif (flaggg == 1):
            print("circulo de radio:",analizados[v+2][1],"me quedo con 1 mas")

            img_new = self.blanco_afuera_del_circulo(img_new, int(analizados[v+2][1]))

        return img_new
        '''
            
        
    def get_light(self):
        if (len(self.img) == 0):
            self.mostrar_mensaje_error("Se necesita cargar una imagen primero")
        else :
            self.img_luz = self.calcular_region(self.img, seccion ="luz", paso_circulos = 2) #calculo el de mayor radio
            pixmap = self.makePixmap(self.img_luz)
            self.label_2.setPixmap(pixmap)
            
            self.flag_luz = self.flag_placa+1
            self.Placa.show()

    
    def get_placa(self):
        if (len(self.img) == 0):
            self.mostrar_mensaje_error("Se necesita cargar una imagen primero")
        else:
            placa_full = self.calcular_region(self.img, seccion ="placa", paso_circulos = 2)
            aux = self.calcular_region(self.img, seccion ="luz", paso_circulos = 2)
            self.img_placa = placa_full - aux

            pixmap = self.makePixmap(self.img_placa)
            self.label_2.setPixmap(pixmap)
            
            self.flag_placa = self.flag_luz+1

    def region_growing(self, imagen, semilla, limite_inferior, limite_superior, valor):
        filas, columnas = imagen.shape
        x_semilla, y_semilla = semilla
        imagen_resultado = np.zeros((filas, columnas), dtype=np.uint8)
        lista_semillas = [(x_semilla, y_semilla)]
        semillas_analizadas = set()

        while lista_semillas:
            semilla_actual = lista_semillas.pop(0)
            i, j = semilla_actual
            imagen_resultado[i, j] = valor
            semillas_analizadas.add(semilla_actual)

            for k in range(-1, 2):
                for l in range(-1, 2):
                    nuevo_x, nuevo_y = i + k, j + l

                    if 0 <= nuevo_x < filas and 0 <= nuevo_y < columnas:
                        if limite_inferior < imagen[nuevo_x, nuevo_y] < limite_superior and (nuevo_x, nuevo_y) not in semillas_analizadas:
                            imagen_resultado[nuevo_x, nuevo_y] = valor
                            semillas_analizadas.add((nuevo_x, nuevo_y))
                            lista_semillas.append((nuevo_x, nuevo_y))
                        elif imagen[nuevo_x, nuevo_y] < limite_inferior or imagen[nuevo_x, nuevo_y] > limite_superior and (nuevo_x, nuevo_y) not in semillas_analizadas:
                            imagen_resultado[nuevo_x, nuevo_y] = 0
                            semillas_analizadas.add((nuevo_x, nuevo_y))

        return imagen_resultado

    def mejorar_segmentacion(self):
        if (len(self.img_luz) == 0 and len(self.img_placa) == 0):
            self.mostrar_mensaje_error("Se necesita segmentar la imagen primero")
            
        else:
            if (self.flag_luz>self.flag_placa):
                print("elegi luz")
                img_recortada = self.img_luz
                minimo = 1
                maximo = 50
            else:
                print("elegi placa")
                img_recortada = self.img_placa
                minimo = 25
                maximo = 70
            posiciones = np.where((img_recortada != 0) & (img_recortada != 255))
            seed = (posiciones[0][len(posiciones[0])//2], posiciones[1][len(posiciones[1])//2])
            img_RG = self.region_growing(img_recortada, seed, minimo, maximo, 200)
            #Img_RG = sitk.ConnectedThreshold(img_recortada, seedList=[(280,280)], lower=1, upper=254)
            #Img_RG_array = sitk.GetArrayFromImage(Img_RG)
            pix = self.makePixmap(img_RG);

            self.label_2.setPixmap(pix);
            print("Termine")

    
    def parametros(self):
        #Acá se calculan los parámetros Area 1 y Area 2 y se muestran

        return



    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.Imagen.setText(_translate("MainWindow", "Importar imagen"))
        self.label.setText(_translate("MainWindow", "TextLabel"))
        self.label_2.setText(_translate("MainWindow", "TextLabel"))
        self.Segmentar.setText(_translate("MainWindow", "Segmentar"))
        self.Luz.setText(_translate("MainWindow", "Luz"))
        self.Placa.setText(_translate("MainWindow", "Placa"))
        self.Mejorar.setText(_translate("MainWindow", "Mejorar segmentación"))
        self.Calcular.setText(_translate("MainWindow", "Calcular parámetros"))
        self.min.setText(_translate("MainWindow", "Imagen de inicio:"))
        self.textEdit.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Area 1: </p></body></html>"))
        self.textEdit_3.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Area 2: </p></body></html>"))
        self.textEdit_4.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">Coeficiente:</p></body></html>"))
        

            
class MainWindow(QtWidgets.QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)
        self.setWindowTitle("Electrocardiograma")
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        self.setWindowTitle("Los PIBardos")

    def keyPressEvent(self, event):
        if event.key() == QtCore.Qt.Key_Escape or event.key() == QtCore.Qt.Key_Space:
            self.showNormal()

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
      
    window.showFullScreen()
    app.installEventFilter(window)
    sys.exit(app.exec_())
